# 7 프로세스의 개념

- process(프로세스): 실행 중인 program(프로그램)

- 프로그램은 단지 디스크 상에 존재한다. 명령어와 정적 데이터의 묶음 그 이상 그 이하도 아니다.

- 이 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 불어 넣는 것이 바로 운영체제 (Operating System).

- 우리가 일반적으로 컴퓨터를 사용할 때, 웹 브라우저, 메일 클라이언트, 게임, 음악 플레이어 등을 동시에 수십 개의 프로세스를 실행한다.

- 우리는 사용 가능한 CPU가 몇 개 있는지 신경쓰지도 않는다. 그렇다면 우리의 핵심 질문은 다음과 같다.

- **CPU가 여러 개 존재한다는 환상을 어떻게 재공하는가?**

- 적은 개수의 CPU만으로, OS는 어떻게 무한 개에 가까운 CPU 있다는 환상을 만드는 걸까?

- OS가 CPU를 가상화해서! 환상을 만든다.

- 그렇다면 어떻게 가상화를 할까?

- time sharing(시분할) 기법을 이용해서

- OS에서 time sharing 기법을 잘 구현하려면, 저수준의 도구인 mechanism과 고차원적인 지능인 policy가 필요하다.

- context switch의 구현이 메커니즘의 예이다.

- 고차원적인 지능인 policy의 예로는 scheduling policy가 있다.

# 7.1 프로세스의 개념

- 프로세스의 구성 요소를 이해 하기 위해서 -> machine state를 이해해야 한다.

- machine state 중 중요한 구성 요소: 메모리(address space), 프로그램 카운터(PC)

# 7.2 프로세스 API

- OS가 반드시 API로 제공해야 하는 몇 가지 기본 기능

- 프로세스의 생성(Create), 제거(Destroy), 대기(Wait), 각종 제어(Miscellaneous Control), 상태(Status)

# 7.3 프로세스 생성: 좀 더 자세하게

- 한 가지 미스테리: 프로그램이 어떻게 프로세스로 변형될까?

- OS가 프로그램 실행을 위해서 하는 1번 작업은 프로그램 코드와 static data를 메모리, 프로세스의 주소 공간에 load한다.

- program은 SSD에 binary로 존재.

- OS는 SSD의 해당 바이트를 읽어서 메모리 어딘가로 저장.

- 초기 OS는 코드와 데이터를 모두 메모리에 탑재 했으나, 현대 OS는 이 작업을 늦춘다.

- 프로그램을 실행하면서 코드나 데이터가 필요할 때만 메모리에 탑재.

- 이를 정확하게 이해하려면 paging과 swapping 동작의 이해가 필요.

- 코드와 정적 데이터가 메모리로 탑재된 이후에는 일정량의 메모리가 프로그램의 run-time stack 용으로 할당 돼야 함.

- heap을 위한 메모리 영역도 할당한다.
- 입출력 셋업과 관계된 작업도 한다.

- 이후에 프로그램의 시작 지점인 entry point, 즉 `main()`에서부터 프로그램을 실행시킨다.

# 7.4 프로세스 상태

- 프로세스 상태를 단순화하면 다음 세 상태 중 하나에 존재
  - Running
  - Ready
  - Blocked

# 7.5 자료 구조

- OS도 일종의 프로그램이다. 그래서 다른 프로그램들과 같이 다양한 정보를 유지하기 위한 자료 구조를 갖고 있다.

- 예를 들어, 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 process list와 같은 자료 구조.

- register context: 프로세스가 중단됐을 때 해당 프로세스의 레지스터 값들을 저장

- 이 레지스터 값들을 복원하여 OS는 프로세스 실행을 재개한다.

- 이를 context switch라고 한다.
