# 막간: 메모리 관리 API

- UNIX의 memory 관리 interface를 다룬다.
- 여기서 메모리 === 사용자 주소 공간

# 메모리 공간의 종류

- C Program이 실행되면, 2 가지 유형의 memory 공간이 할당 된다.

1. stack => 할당과 반환은 컴파일러에 의해 암묵적으로, automatic memory

- stack에 메모리를 선언하는 건 쉽다.

```c
void func() {
    int x; // stack에 int형을 선언
}
```

- 컴파일러가 알아서 func가 불리면 스택에 공간을 확보하고, ret하면 메모리를 반환

2. heap => 모든 할당과 반환이 프로그래머에 의해 명시적으로 처리

```c
void func() {
    int *x = (int *) malloc(sizeof(int));
}
```

- 코드 한 줄에서 스택과 힙 할당이 모두 발생
- 컴파일러가 포인터 변수`int *x`를 만나면, int 포인터를 위한 공간을 할당
- malloc()을 호출하여 int를 위한 공간을 힙으로부터 요구

# `malloc()` 함수

- `malloc()`의 인자는 `size_t` 타입의 변수이고, 이 변수는 필요 공간의 크기를 바이트 단위로 표시
- `sizeof()`는 통상 컴파일 타임 연산자이다. 그래서 `sizeof(double)`은 double의 크기인 8로 대체되어 `malloc()`에 전달된다.
- 참고로 `sizeof()`는 함수 호출이 아니라, 연산자이다. (함수 호출은 runtime에 일어난다.)

```c
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x));
```

- 첫 번째 행에서, int 원소 10개를 가지는 배열을 위한 공간을 선언했고, 다음 줄에서 `sizeof()` 연산자를 이용하여, 그 값을 출력했다. 여기서 `sizeof()` 연산자를 사용하면, 4 또는 8이 출력된다.

- 이 경우에는 `sizeof()`는 runtime에 동적으로 할당받은 메로리의 크기가 얼마인지가 아니라, 정수를 가리키는 포인터의 크기가 얼마인지 물어 본다고 생각하기 때문이다. 그런데 또 때때로 `sizeof()`는 기대한 대로 동작할 때가 있다.

```c
int x[10];
printf("%d\n", sizeof(x));
```

- 이 경우에는 변수 x에 40B가 할당됐다는 걸, 컴파일러가 알 수 있는 정적인 정보가 충분

- 또 하나 조심해야 하는 경우: 문자열을 다룰 때

- `malloc(strlen(s) + 1)`. 이 문장은 `strlen()` 함수를 사용하여 문자열의 길이를 얻어낸 뒤 null-character를 위해 1B를 더한다. `sizeof()` 사용은 여기서 문제를 일으킬 수 있다.

# `free()` 함수

- 힙 메모리를 해제하기 위해서는 프로그래머는 `free()`를 호출한다.

```c
int *x = malllco(10 * sizeof(int));
//중략
free(x);
```

- `malloc()`은 한 개의 인자, 반환된 포인터를 받는다. 할당된 영역의 크기는 전달 X. 할당된 메모리의 크기는 메모리 할당 라이브러리가 알고 있어야 한다.

# 흔한 오류

- `malloc()`과 `free()`를 사용하는 데 흔히 발생하는 오류가 많다.

- 메모리 할당 잊어 버리기

```c
char *src = "hello";
char *dst; // 아뿔싸! 할당이 안 됐네
strcpy(dst, cpy) // segfault 그리고 죽는다.
```

- 불법적인 메모리 접근을 세그멘테이션 폴트라고 불리는데, 곧 배우게 될 것이다.

- "네가 모리 관련 무언가를 잘못했어. 이 병신아. 그래서 나 화났음."

- 올바른 코든는 다음과 같이 바꿀 수 있다.

```c
char *src = "hello";
char *dst = (char *)malloc(strlen(src)); //너무작다!
strcpy(dst, src); // 그렇지만 제대로 동작
```

- 대신에 `strdup()`을 사용하면 훨씬 편하게 할 수 있다.

## 메모리를 부족하게 할당 받기

- a.k.a buffer overflow
- 앞의 예에서 목적지 버퍼 공간을 약간 부족하게 할당받는 것.

## 할당받은 메모리 초기화하지 않기

- `malloc()`을 제대로 호출했지만, 새로 할당받은 데이터 타입에 특정 값을 넣는 것을 잊는 것.

-초기화되지 않는다면, 프로그램은 결국 uninitialized read를 하는 것이다.

- 임의의 값이나 해로운 값이 읽힐 것이다.

## 메모리 해제하지 않기

- memory leak(메모리 누수)
- 장시간 실행되는 application이나 os 같은 시스템 프로그램에서 문제다.
- 메모리가 천천히 누수되면 결국 메모리가 부족 => 시스템을 재시작 할 수밖에 없기 때문이다.
- 메모리 청크의 사용이 끝나면 반드시 해제해야 된다.

## 메모리 사용이 끝나기 전에 메모리 해제하기

- 메모리 사용이 끝나기 전에 메모리를 해제한다. 그런 실수는 dangling pointer라고 불리며 심각한 실수이다. 차후 그 포인터를 사용하면 프로그램을 크래시시키거나 유효 메모리 영역을 덮어쓸 수 있다. 예... `free()`를 호출하고, 그 후 다른 용도로 `malloc()`을 호출하면 잘못 해제된 메모리를 재사용한다. (이해 안 됨)

## 반복적으로 메모리 해제하기

- 메모리를 한 번 이상 헤재하면 double free라 불린다.
- 결과 예측은 힘들다

## `free()` 잘못 호출하기

- `free()`를 잘못 호출하는 것이다. `free()`는 `malloc()`이 받은 포인터만 전달될 것으로 예상한다. 그 이외의 값을 전달하면 문제가 발생한다. invalid frees는 위험하다.

# 운영체제의 지원
