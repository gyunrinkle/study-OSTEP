# 가정

1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 각 작업은 시작되면 완료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다(즉, 입출력을 수행하지 ᦫ는다).
5. 각 작업의 실행 시간은 사전에 알려져 있다.

# 스케줄링 평가 항목

## **성능** 측면

- 반환 시간(turnaround time)
  - $T_{turnaround} = T_{completion} − T_{arrival}$

## 또 다른 측면

- 공정성(fairness)

성능과 공정성은 서로 상충 됨. 성능을 극대화하기 위해 몇몇 작업의 실행을 중지하면, 결과적으로 공정성이 약화.

# FIFO

먼저 들어온 프로세스를 먼저 처리

## 예시

- 시스템에 Process A, B, C가 거의 동시에 도착 ($T_{arrival} = 0$).

- 간발의 차이로 A, B, C 순으로 도착했다고 가정.

| 프로세스  |    0 ~ 20    |   20 ~ 40    | 40 ~ 60 | 60 ~ 80 | 80 ~ 100 | 100 ~ 120 |
| :-------: | :----------: | :----------: | :-----: | :-----: | :------: | :-------: |
| Process A | ██████░░░░░░ |              |         |         |          |           |
| Process B | ░░░░░░██████ |              |         |         |          |           |
| Process C |              | ██████░░░░░░ |         |         |          |           |

이 작업들의 평균 turnaround time은 ${(10 + 20 + 30)\over3}=20$

여기서 우리가 가정했던 1번 가정을 완화해 보자. 예를 들어, A, B, C 작업이 각각 100, 10, 10이 시간이 걸린다고 가정하자.

| 프로세스  |    0 ~ 20    |   20 ~ 40    |   40 ~ 60    |   60 ~ 80    |   80 ~ 100   |  100 ~ 120   |
| :-------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| Process A | ████████████ | ████████████ | ████████████ | ████████████ | ████████████ |              |
| Process B |              |              |              |              |              | ██████░░░░░░ |
| Process C |              |              |              |              |              | ░░░░░░██████ |

그러면 이 시스템에서 평균 반환 시간은 ${(100 + 110 + 120)\over3}=110$ 으로 늘어난다. 이를 **convoy effect**라 한다.

# SJF

가장 짧은 작업을 먼저 처리

## 예시

방금 FIFO에서 다뤘던 예시를 SJF로 처리하면 다음과 같다.

| 프로세스  |    0 ~ 20    |   20 ~ 40    |   40 ~ 60    |   60 ~ 80    |   80 ~ 100   |  100 ~ 120   |
| :-------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| Process A |              | ████████████ | ████████████ | ████████████ | ████████████ | ████████████ |
| Process B | ██████░░░░░░ |              |              |              |              |              |
| Process C | ░░░░░░██████ |              |              |              |              |              |

그러면 이 시스템에서 평균 반환 시간은 ${(10 + 20 + 120)\over3}=50$ 으로 줄어 든다. 모든 작업이 동시에 도착한다면 SJF는 Optimal하다.
그런데 모든 작업이 동시에 도착한다는 가정 2는 너무 비현실적이다. 2번 가정을 완화해 보자.

| 프로세스  | 0 ~ 10(B, C 도착) ~ 20 |   20 ~ 40    |   40 ~ 60    |   60 ~ 80    |   80 ~ 100   |  100 ~ 120   |
| :-------: | :--------------------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| Process A |      ████████████      | ████████████ | ████████████ | ████████████ | ████████████ |              |
| Process B |                        |              |              |              |              | ██████░░░░░░ |
| Process C |                        |              |              |              |              | ░░░░░░██████ |

B, C가 10의 시간에 도착해 버리면, A가 끝나기를 기다려야 하므로, convoy effect가 발생한다. 평균 반환 시간은 ${100+(110 - 10)+(120-10)\over3}=103.33$이다.

# STCF

위 문제를 해결하려면, 가정 3을 완화해야 한다. timer interrupt와 context switch를 고려하면, B와 C가 도착했을 때 스케줄러는 딴 일을 할 수 있다. 이제 SJF에 선점 기능을 추가한 STCF(Shortest Time-to-Compltetion First)이다. 시스템에 새로운 작업이 들어오면, 남아 있는 작업과 새로운 들어온 작업의 잔여 실행 시간을 계산하여, 그 중 가장 적은 잔여 실행 시간을 가진 작업을 스케줄한다.

## 예시

| 프로세스  | 0 ~ 10(B, C 도착) ~ 20 |   20 ~ 40    |   40 ~ 60    |   60 ~ 80    |   80 ~ 100   |  100 ~ 120   |
| :-------: | :--------------------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| Process A |      ██████░░░░░░      | ░░░░░░██████ | ████████████ | ████████████ | ████████████ | ████████████ |
| Process B |      ░░░░░░██████      |              |              |              |              |              |
| Process C |                        | ██████░░░░░░ |              |              |              |              |

STCF를 적용한 결과 새로운 반환 시간은 ${120+(20-10)+(30-10)\over3}=50$이다. 새로운 가정 하에서 STCF는 최적의 스케줄러이다.

# 새로운 평가 기준: 응답 시간

## 응답 시간(response time)

- 작업이 도착해서 처음 스케줄 될 때까지의 시간
- $T_{response}=T_{firstrun} - T_{arrival}$

# Round Robin

응답 시간 문제를 해결하기 위해 도입한 스케줄링 알고리즘이다. RR은 작업이 끝날 때까지 기다리지 않는다. 대신 일정시간 동안 실행한 후 실행 큐의 다음 작업으로 전환. 이때 작업이 실행되는 일정 시간을 time slice 혹은 scheduling quantum이라 부른다. RR과 같은 공정한 정책, 즉 작은 시간 단위로 CPU를 분해하는 정책은 반환 시간과 같은 평가 기준에서 성능이 나쁘다.

# 입출력 연산 고려

가정 4를 완화해 보자. 모든 프로그램은 I/O를 수행한다.

## 예시

두 개의 작업 A와 B가 있다고 하자. 각 작업은 50ms의 CPU 시간을 필요로 한다. 그러나 둘은 한 가지 큰 차이를 가진다. A는 10 ms 동안 실행된 후, 입출력 요청을 한다. (여기서 입출력 시간은 10 ms라고 가정한다). 반면에 B는 입출력을 수행하지 않는다. 스케줄러는 A를 먼저 실행시키고 B를 다음에 실행시킨다.

|        |      A       |      A       |      A       |      A       |     A, B      |      B       |      B       |
| :----: | :----------: | :----------: | :----------: | :----------: | :-----------: | :----------: | :----------: |
|  CPU   | ██████░░░░░░ | ██████░░░░░░ | ██████░░░░░░ | ██████░░░░░░ | ██████ ██████ | ████████████ | ████████████ |
| 디스크 | ░░░░░░██████ | ░░░░░░██████ | ░░░░░░██████ | ░░░░░░██████ |               |              |              |
|        |    0 ~ 20    |   20 ~ 40    |   40 ~ 60    |   60 ~ 80    |   80 ~ 100    |  100 ~ 120   |  120 ~ 140   |

STCF 스케줄러를 구현한다고 가정해 보자. A의 각 10ms를 하위 작업을 독립적인 작업으로 다루는 것이다. 그러면 다음과 같이 된다.

|        |     A, B      |      A,B      |      A,B      |      A,B      |     A, B      |           |           |
| :----: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-------: | :-------: |
|  CPU   | ██████ ██████ | ██████ ██████ | ██████ ██████ | ██████ ██████ | ██████ ██████ |           |           |
| 디스크 | ░░░░░░██████  | ░░░░░░██████  | ░░░░░░██████  | ░░░░░░██████  |               |           |           |
|        |    0 ~ 20     |    20 ~ 40    |    40 ~ 60    |    60 ~ 80    |   80 ~ 100    | 100 ~ 120 | 120 ~ 140 |

각 CPU Burst를 하나의 작업으로 간주함으로써 스케줄러는 대화형 프로세스가 더 자주, 즉 유리하게 실행되는 것을 보장한다. 이런 대화형 작업이 입출력을 실행하는 동안 다른 CPU-집중 작업들이 실행되고, CPU의 이용률이 더 높아진다.

# No More Oracle

방금 입출력을 고려한 스케줄링 방식은 스케줄러가 각 작업의 실행 시간을 알고 있다는 가정 하에 구현된 방식이다. 사실 범용 OS에서 프로세스의 실행 시간을 알 길은 없다. 그래서 사전 지식 없이 SJF/STCF 처럼 행동하는 알고리즘을 구축하기란 어렵다. response time까지 좋게 하기 위해 RR 스케줄러의 경우에 보았던 아이디어를 어떻게 하면 포함시킬 수 있을까?

# 요약

우리는 스케줄링의 기본적인 개념과 두 가지 부류의 접근법을 살펴보았다. 첫 번째 부류는 남아 있는 작업 중 실행 시간이 제일 짧은 작􁨦을 수행하고, 반환 시간을 최소화한다. 두 번째 부류는 모든 작업을 번갈아 실행시키고 응답 시간을 최소화한다. 안타깝게도 반환 시간과 응답 시간 중 하나를 최적화하면 나머지 하나는 좋지 않은 특성을 나타낸다. 이는 시스템에서 흔히 보이는 절충을 요구하는 상황이다. 전체적인 그림에 입출력을 어떻게 통합해야 하는지도 보았다. 그렇지만 미래를 예측할 수 없는 운영체제의 근본적인 문제는 해결할 수 없었다. 가까운 과거를 이용하여 미래를 예측하는 스케줄러를 구현하여 이 문제를 어떻게 해결하는지 곧 보게 될 것이다. 이 스케줄러는 멀티 레벨 피드백 큐(multi-level feedback queue) 라고 불리며 다음 장의 주제이다.
